// Package controller is for 
// generated version: {{ .AppVersion }}
package controller

import (
    "strings"
	"net/http"
	"runtime/debug"
    props "{{ .ControllerPropsPackage }}"
    "github.com/labstack/echo/v4"
)

type middleware struct {
    path       string
    middleware echo.MiddlewareFunc
}

type Controllers struct {
    props *props.ControllerProps

    middlewares []middleware
}

func NewControllers(
    props *props.ControllerProps, e *echo.Echo, 
) *Controllers {
    ctrl := &Controllers{}
    
    e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            for _, m := range ctrl.middlewares {
                if strings.HasPrefix(c.Request().URL.Path, m.path) {
                    next = m.middleware(next)
                }
            }

            return next(c)
        }
    })
    e.Use(func(before echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) (err error) {
			defer func() {
				recoverErr := recover()
				if recoverErr == nil {
					return
				}

				debug.PrintStack()

				if httpErr, ok := recoverErr.(*echo.HTTPError); ok {
					err = c.JSON(httpErr.Code, httpErr.Message)
				}

				err = c.JSON(http.StatusInternalServerError, map[string]interface{}{
					"code":    http.StatusInternalServerError,
					"message": "internal server error.",
				})
			}()

			return before(c)
		}
	})

    addRoutes(e, props)

    return ctrl
}

func (c *Controllers) AddMiddleware(path string, m echo.MiddlewareFunc) {
    c.middlewares = append(c.middlewares, middleware {
        path: path,
        middleware: m,
    })
}
